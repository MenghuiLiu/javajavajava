
jvm内存模型
线程私有：本地方法栈、虚拟机栈、程序计数器（线程运行的位置，多线程之间的切换）
线程共享：堆、方法区（class字节码文件、常量池、静态变量）

jvm问题工具,jps,jinfo,jmap...
jps查看进程id，jinfo查看系统jvm信息，jmap查看jvm物理内存占用情况

String a=“a”;String b=“b”; 问"a" "b"等不等于a b
字符存在常量池里边，使用==比较的是具体的数据

Java中堆栈的区别。堆栈的增长方向有哪些不同？

jvm最大内存限制多少 ? 在一台16G内存的机器上，JVM默认内存空间多大？
堆内存最小1/64，最小1/4 栈内存最小1/64，最小1/4 整体32位机器4g，64位机器理论上无限制

jvm是如何实现线程？
程序计数器

了解过字节码的编译过程吗
语法分析、词法分析、语义分析、中间代码生成、优化、目标代码生成

eden区，survial区?

垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？（垃圾回收）
gc通过有向图的方式监控jvm里边的对象，通过判断可达不可达的方式来决定是否回收该对象。System.gc建议垃圾收集器进行回收动作。

JVM回收算法和回收器，CMS采用哪种回收算法，怎么解决内存碎片问题？ 为什么年轻代要用复制算法?并发标记阶段处理速度慢的原因可能是什么。怎么进行优化
标记清除、标记整理、复制算法。CMS可以在进行一定次数的标记清除之后进行一次标记整理算法。年轻代的GC是在survive1和survive2之间移动，刚好符合复制算法
把内存分为两部分的场景。并发标记阶段处理速度慢的原因可能是要标记处理的对象太多了，可以在remark之前进行一次yongGC，减少重新标记
要扫描的年轻代对象数目。

阐述GC算法 , 那并发量很高时，使用哪种算法？
ParNewGC（年轻代、标记整理 与CMS配合使用）、CMS、G1（可指定STW停顿时间，G1会在GC回收时自己判断该region回收的价值）

GC如何调优?
调优原则是让年轻代的对象尽可能晚的到老年代，减少full gc的次数，减少STW的时间。
通过jstat判断年轻代比例、查看GC回收次数，查看堆内存的大小。

什么时候回引发 OOM（Out Of Memory）异常
要分配对象使用的内存不够用时，会OOM；gc与非gc时间耗时之比大于GCTimeRatio的限制时，引发OOM（Out Of Memory）异常。

垃圾回收触发条件 ? 是需要回收就立即回收，还是怎么办？通常哪些设为安全点？
Eden区（也就是新生代）中已经满了之后，进行minor gc；当提升到老年代的对象超过了老年代的剩余空间的时候会发生full gc。

GC中如何判断对象需要被回收？ 一个方法中有A a = new A();这么一条语句，方法执行完后A的实例化对象在GC时能否被回收掉
通过gcroot，判断对象可达不可达，且不用执行finalize方法，如果没有关联到gcroot，下次回收时就大概率会被回收掉。gcroot一般指的是虚拟栈中引用的对象，本地方法栈中引用的对象，方法区里边静态属性引用的变量。

什么时候会触发full gc? FullGC是否停顿用户线程?发生Full GC的时候，一定会发生stop the world吗？怎么避免full gc ? 频繁出现full gc应该如何排查?
老年代满了之后会发生full gc，会stw，避免full gc可以把堆的内存调大点。频繁发生fullgc可以看下堆里边都存放了哪些对象，业务代码上是否发生了内存泄漏。

minor gc如果运行的很频繁，可能是什么原因引起的，minor gc如果运行的很慢，可能是什么原因引起的?
minorgc运行频繁：eden区太小 minorgc运行慢：新生代空间设置过大；对象引用链较长，进行可达性分析时间较长；新生代survivor区设置的比较小，清理后剩余的对象不能装进去需要移动到老年代，造成移动开销。

对象怎么分配内存，基于什么原则；
对象优先分配到eden区；大对象直接分配在老年代，以节约年轻代空间；长期存活的对象进入老年代；
年轻代动态年龄判断，当survivor区同一年龄的对象大小占据survivor内存空间的一半，将大于等于该年龄的对象放到老年代；
空间分配担保机制，当eden区空间不够对象分配使用时，就像老年代租借内存，若老年代也不够用，就会发生full gc。


类加载过程 ? 初始化阶段是干什么的?
加载（字节码文件）、校验（文件格式、元数据、符号引用）、准备（常量池中给static变量赋默认初始值）、解析（将符号引用替换为直接
引用）、初始化（为类的静态变量赋予正确的初始值）

双亲委派模型的好处是什么？
保证jdk核心类的优先加载。

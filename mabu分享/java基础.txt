String、stringbuilder、stringbuffer区别：

String源码中的value char数组用final修饰，表明其引用的地址不可改变，另外string的substring和concat等方法，返回值都是value数组复制出来的，因为说string不可改变。

stringbuffer可以说是可修改的string，因为其主要方法都是由synchronized修饰，因而是线程安全的。

stringbuilder是单线程下可变的字符串对象，相较于stringbuffer线程不安全，但是效率更高。

 

对象的深浅复制：浅复制只是单存的复制对象，对于对象内部关于其他对象的引用则不复制。深复制则是对象及其内部的引用都会复制，复制出来的对象跟原来的没有什么关联关系了。

实习浅复制的办法是重写对象的clone方法，直接通过super.clone()方法实现。深复制的办法也可以通过重写clone方法，对对象的每个属性都进行复制，还可以通过对象的序列化把信息存放到磁盘上，然后再通过反序列化解析出，实现深复制，很明显，对于transient修饰的属性，就不会保留下来了。

 

一个十进制的数在内存中是如何存储的：是以原码的补码形式存储的，正数的补码就是其原码，负数的补码是其反码加一，在求反码的过程中是符号位不变，其他位求反。

 

Java支持的基本数据类型：整数型byte、short、int、long，浮点类型float、double，字符型char，布尔型boolean。

 

自动拆装箱：就是指基本数据类型与对应的包装类型之间的一个转化，基本数据类型转包装类型叫装箱，反之则叫拆箱。

 

Integer和int的区别及什么时候用int和Integer：int是基本数据类型，默认值是0，Integer是包装类型，是一个对象，默认值是null，在实际场景中如果需要区分0和null，就可以使用Integer。除此之外，Integer里边定义了整数的最大值和最小值。

 

==比较的是什么：对于基本数据类型，比较的是值，对于引用的类型，比较的是地址。

 

equals和hashcode方法的区别及为什么重写equals一定要重写hashcode：equals方法是比较两个对象是否相同，object类的equals方法源码是用的==，实际上是比较的内存地址。而我们通常希望比较的是两个对象的值，所以要重写equals方法。

Hashcode方法运用比较普遍的地方就是hash表，把key可以根据hashcode方法映射到具体的位置，这样可以加快查询效率。Object类中的hashcode方法是根据对象的内存地址去计算的。

另外的话，计算key的hashcode有可能会产生hash冲突，就是不同的key值，得到了相同的hashcode。一般来讲，两个对象通过equals比较相等，hashcode方法的返回值也一样，hashcode方法的返回值一样，两个对象equals不一定相等，因为hash冲突的存在。

为什么重写equals一定要重写hashcode，是因为在java中的hashset和hashmap等集合中get元素时，会首先比较hashcode一不一样，若一样再比较equals是不是true，若hashcode不一样，就认为key值不一样。假若两个对象属性值一样但是hashcode不一样，我们只重写了equals认为两个对象相等，在集合类中显然就不认为这两个对象相等，不是我们想要的。

 

float、double在计算机内存中是如何存储的和decimal的区别：float和double都是浮点数的基本数据类型，float占4个字节，double占8个字节，因此double有更高的精度。

在内存中存储的时候，采用的是符号+指数+尾数三部分存储。符号就是0正1负。指数和尾数的计算是把浮点数转换成1.XX * 2的指数方形式，然后在存储指数的时候，2的具体多少次方加上127，例如2的4次方，那要储存的指数就是131，然后取131的二进制形式。尾数就是1后面的部分，例如1.0011，那尾数就是0011。

另外在转换成指数方形式的时候，是整数部分采用膜2取余法，小数部分采用乘2取整数。

float和double和decimal区别：float的有效数字位数是7位，double是15个有效位。对于

decimal，它是一个类，因此占用的内存空间主要看实例的大小，主要是用于账目金额运算。在精度丢失的场景下，要用decimal替换掉float和double，另外要注意的是，要使用decimal的构造函数传参为string的，才会避免出现精度丢失的情况，若使用的是基本数据类型的构造函数，decimal对象的引用指向的还是基本数据类型。

Biglnteger类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。

 

为啥有时会出现4.0-3.6=0.40000001这种现象:是因为在二进制系统中无法准确表示1/10，就像在十进制计数中，1/3无法表示一样。二进制能表示的数值得能转化成1/2的n次方的形式才行。

 

char可以存汉字吗，底层怎么存的：char存储的是Unicode编码，Unicode编码中存在中文，所以char可以存汉字。另外一个char占两个字节，一个汉字也占两个字节，

 

Java的字符集是什么：Unicode字符集包含了字库表中的每个字符对应的码位，根据码位可以找到对对应的字符。然后UTF-8等编码规则包含了每个码位对应的在计算机中的存储的字节序列。

另外广义的Unicode是一个标准，里边定义了Unicode字符集及各种各样的编码规则。UTF-8是一个以8位为编码单位的可变长的编码规则，可以将一个码位编码成1到4个字节。

 

什么是值传递和引用传递：主要是涉及到实参和形参，值传递就是对形参的改变不影响实参，引用传递就是对形参的改变会影响实参。对于基本数据类型，都可以认为是值传递，对于对象的传递，除了String对象，都可以认为是引用传递，这个时候，形参和实参实际指向的是同一个内存地址。因为参数传递本质上还是赋值操作，所以引用传递有的人讲也是值传递，是对象的引用的传递，不过这种字面上的区分没有意义。

 

&和&&的区别：首先都是逻辑与运算，另外&&还是短路预算符，即只要符号左边不成立，右边的就不会执行。另外&还是位运算符。

 

数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？：
Array：数组只能存储同一类型的数据，例如基本数据类型和对象类型。并且数组定义的时候就要初始化长度，且不能改变。
ArrayList：集合只能存储对象类型，如果要存储基本数据类型可以装箱存对应的包装类型，但支持动态扩容。

在不确定存储数据的大小时，使用ArrayList，确定了长度且数据类型一致的时候就可以使用array。

 

在Java中，如何跳出当前的多重嵌套循环：第一种就是在最外边的循环里用break；第二种使用标记，然后break到标记的位置。

 

在Java中String类为什么要设计成final？String真的不可变吗?其他基本类型的包装类也是不可变的？
设计成final不可变支持线程安全；不可变性支持把string字符串放到常量池中，提升性能；

String比较常用，不可变保证了不可被随意篡改，保证了数据的安全性。

String底层使用的是一个char[]存储的，被final修饰，既然是char[]数组，肯定有办法改变，没法改变的只是这个数组的引用地址，可以通过反射更改char[]的值，从而改变String。

其他基本类型的包装类型也都是用final修饰的value存储，都不可变。

 

简述正则表达式及其用途及Java中是如何支持正则表达式操作的:
正则表达式就是描述复杂字符串规则的代码，使用它可以方便的进行字符串匹配。
java中的string提供了matches()、replaceAll()、replaceFirst()、split()等支持正则表达式的方法，另外提供了一个pattern的正则表达式对象。
 

讲一讲Java里面的final关键字怎么用的:用来修饰成员变量和局部变量，表示该变量只能被赋值一次 且不能更改;用来修饰方法参数表示在方法体内不能修改;用来修饰方法表示该方法不能被重写;用来修饰类表示该类不能被集成。
 

Java 8 如何实现的函数式编程：通过lambda表达式和stream实现函数式編程。1 ambda表达式的参数类型就是函数式接口，即只有一个抽象方法的接口。另外java8 提供了java. util, function,提供了常用的函数式接口。Stream 是数据源的一种视图，并不会修改数据。另外Stream提供了常用的函数，例如concatO, max(), min()等。


如何保证接口的幂等性：接口幂等性是指对于用户的某个业务场景下的操作，无论请求了几次，结果都是一样的，不会因为点击多次而带来副作用。就像发起订单，扣款一样，不会产生多付少付的情况。
保证接口的幂等性的办法：通过业务逻辑判断；设置唯一的业务ID，处理完成之后更新对应的状态。
 

Java中的序列化的作用，serialVersionUID作用? 各种序列化器，序列化协议，为什么这个序列化那么快：

内存中的对象只有转化成二进制流才可以进行持久化和网络传输，这个转化过程就叫序列化，反过来，由二进制流转化成对象就叫反序列化。

序列化需要注意的点：transient修饰的属性和static属性不会被序列化。对象的类名、属性会被序列化，方法不会被序列化。

在java里边对一个对象序列化之后，会保存类的元数据等信息，例如类名、属性名等，如果设置了serivalVersionUID，也会被保存进去。在执行反序列化的时候，会对照serialVersionUID的值一样不，如果一样，就可以反序列化成功，否则就会报错。当类没有设置serialVersionUID的时候，会根据类名等元数据去匹配，执行反序列化，有一个场景，就是对一个对象序列化到磁盘上之后，给类重新设置了serialVersionUID，则执行反序列化的时候一定会报错。

常见的序列化协议有XML、JSON等

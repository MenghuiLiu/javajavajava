最重要的索引及底层实现
①聚集索引
聚集索引就是以主键创建的索引
每个表只能有一个聚簇索引，因为一个表中的记录只能以一种物理顺序存放，实际的数据页只能按照一颗 B+ 树进行排序
表记录的排列顺序和与索引的排列顺序一致
聚集索引存储记录是物理上连续存在
聚簇索引主键的插入速度要比非聚簇索引主键的插入速度慢很多
聚簇索引适合排序，非聚簇索引不适合用在排序的场合，因为聚簇索引叶节点本身就是索引和数据按相同顺序放置在一起，索引序即是数据序，数据序即是索引序，所以很快。非聚簇索引叶节点是保留了一个指向数据的指针，索引本身当然是排序的，但是数据并未排序，数据查询的时候需要消耗额外更多的I/O，所以较慢
更新聚集索引列的代价很高，因为会强制innodb将每个被更新的行移动到新的位置
②非聚集索引
除了主键以外的索引
聚集索引的叶节点就是数据节点，而非聚簇索引的叶节点仍然是索引节点，并保留一个链接指向对应数据块
聚簇索引适合排序，非聚簇索引不适合用在排序的场合
聚集索引存储记录是物理上连续存在，非聚集索引是逻辑上的连续。 

索性失效的场景
复合索引的无序使用、in的时候索引可能失效、不要在索引上使用任何操作例如to_char()、复合索引上不能使用!= <> is null is not null、
不要使用like '%xx%'全模糊匹配、不要使用隐式类型转换、尽量不要使用or

最左原则
复合索引，最左优先，以最左边的为起点任何连续的索引都能匹配上

查看执行计划
①id：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
②type：system > const > eq_ref > ref > range > index > ALL，一般来说，好的sql查询至少达到range级别，最好能达到ref
system：表只有一行记录（等于系统表）
const：表示通过索引一次就找到了，只需匹配一行数据
eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
ref：非唯一性索引扫描，返回匹配某个单独值的所有行
range：只检索给定范围的行，使用一个索引来选择行。一般就是在where语句中出现了bettween、<、>、in等的查询
index：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL块，应为索引文件通常比数据文件小
ALL：Full Table Scan，遍历全表以找到匹配的行 
③key：实际使用的索引，如果为NULL，则没有使用索引。
④rows：根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数
⑤key_len：表示索引中使用的字节数，查询中使用的索引的长度
⑥Extra：不适合在其他字段中显示，但是十分重要的额外信息
Using filesort：mysql对数据使用一个外部的索引排序，而不是按照表内的索引进行排序读取。也就是说mysql无法利用索引完成的排序操作成为“文件排序” 
Using temporary：使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表
Using index：表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高

Myiasm和innodb的区别
Myiasm是mysql默认的存储引擎，不支持数据库事务，行级锁，外键；插入更新需锁表，效率低，查询速度快，Myisam使用的是非聚集索引
innodb支持事务，底层为B+树实现，适合处理多重并发更新操作，普通select都是快照读，快照读不加锁。InnoDb使用的是聚集索引

然后是锁的类型，行级表级
InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
InnoDB 自动给修改操作加锁，给查询操作不自动加锁
行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。

共享锁、独占锁
又称读写锁，通过for update（独占）、lock in share mode（共享）

悲观乐观锁
先获取锁、再进行业务操作;更新数据的时候再加锁判断，利用version_number

解释数据库事物及特性
ACID,原子性、一致性、隔离性、永久性

隔离级别
读未提交、读已提交、可重复读、串行化

redo log .undo log
通过预写日志方式实现的，redo和undo机制是数据库实现事务的基础
redo日志用来在断电/数据库崩溃等状况发生时重演一次刷数据的过程，把redo日志里的数据刷到数据库里，保证了事务 的持久性（Durability）
undo日志是在事务执行失败的时候撤销对数据库的操作，保证了事务的原子性

bin log主从复制
主库db的更新事件（update、insert、delete）被写到binlog
主库创建一个binlog dump thread线程，把binlog的内容发送到从库
从库创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
从库还会创建一个SQL线程，从relay log里面读取内容写入到slave的db

mvcc,Next-Key Lock
行锁机制
记录锁：记录锁很好理解，是给某个单行记录上锁；
间隙锁：间隙锁则是锁定的记录之间的间隙，或者是第一个记录之前和最后一个记录之后的范围，
临键锁：临键锁可以说是间隙锁+记录锁，不仅会锁定了间隙，还锁定了记录本身，临键锁解决了幻读的问题（mysql解决幻读的手段）。
mvcc：多版本并发控制，读写锁场景。

delete truncate 区别
delete会删除内容，不释放空间，原先记录的标识还在，属于dml语句，支持回滚，占用的日志资源多；
truncate会删除内容，释放空间，属于ddl语句，改变了表结构，占用的日志资源少。

SQL 中select…limit and offset 会有什么问题，怎么解决
LIMIT 1000000, 30 的意思是：扫描满足条件的1000030行，扔掉前面的1000000行，然后返回最后的30行；
改造成select t.* from ( select id from mytable order by id limit 1000000, 30 ) q left join mytable t on t.id = q.id
子查询只用到了索引列，没有取实际的数据，所以不涉及到磁盘IO，所以即使是比较大的 offset，查询速度也不会太差。

一条SQL语句在MySQL中会经过怎样的过程
客户端->server层->引擎层
server层中又分为连接器、分析器、查询缓存、优化器以及执行器几部分。
引擎层则是主要负责存储数据，提供读写接口。